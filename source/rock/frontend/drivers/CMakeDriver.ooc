// sdk stuff
import io/[File, FileWriter]
import structs/[List, ArrayList, HashMap]

// our stuff
import Driver, MetaDriver, CCompiler, Flags, SourceFolder

import rock/frontend/[BuildParams, Target]
import rock/middle/[Module, UseDef]
import rock/backend/cnaughty/CGenerator
import rock/io/TabbedWriter

/**
 * Generate the .c source files in a build/ directory, along with a
 * CMakefile that allows to build a version of your program without any
 * ooc-related dependency.
 */
CMakeDriver: class extends MetaDriver {

    init: func (.params) { super("CMakeLists.txt", "CMake driver", params) }

    getWriter: func(flags: Flags, toCompile: ArrayList<Module>, module: Module) -> MetaDriverWriter {
        CMakefileWriter new(params, makefile, flags, toCompile, module, originalOutPath)
    }

}

CMakefileWriter: class extends MetaDriverWriter {

    file: File
    flags: Flags
    params: BuildParams
    tw: TabbedWriter
    toCompile: ArrayList<Module>
    module: Module
    originalOutPath: File

    init: func (=params, =file, =flags, =toCompile, =module, =originalOutPath) {
        tw = TabbedWriter new(FileWriter new(file))
    }

    write: func {
        "Writing to %s" printfln(file path)
        writePrelude()
        writeBasicConfig()
        writeProject()
        writePkgConfig()
        writeThreadFlags()
        writeBasicFlags()
        writeFlags()
        writeIncludes()
        writeSources()
        writeExecutable()
    }

    writePrelude: func {
        tw writeln("# CMakeLists.txt generated by rock, the ooc compiler written in ooc")
        tw writeln("# See https://github.com/fasterthanlime/rock and http://ooc-lang.org")
        tw nl()
    }

    writeBasicConfig: func{
        tw writeln("cmake_minimum_required (VERSION 2.6)")
        tw nl()
        //tw writeln("set(${CMAKE_EXE_LINKER_FLAGS} \"${CMAKE_EXE_LINKER_FLAGS} -ldl -lm\")")
        tw nl()
    }

    writePkgConfig: func {
        tw writeln("include(FindPkgConfig)")
    }

    writeThreadFlags: func {
        tw writeln("find_package (Threads)")
        tw writeln("set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${Threads_INCLUDE_DIRS}\")")
        tw writeln("if(CMAKE_USE_PTHREADS_INIT)")
        tw writeln("  set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ${CMAKE_THREAD_LIBS_INIT}\")")
        tw writeln("endif(CMAKE_USE_PTHREADS_INIT)")
        tw nl()
    }

    writeBasicFlags: func {

        tw writeln("set(CMAKE_C_FLAGS_DEBUG \"-g -O0 -fno-inline ${CMAKE_C_FLAGS_DEBUG}\")")
        tw writeln("set(CMAKE_C_FLAGS_RELEASE \"-O3 ${CMAKE_C_FLAGS_RELEASE}\")")
    }

    writeFlags: func {
        tw writeln("if(CMAKE_SIZEOF_VOID_P EQUAL 8)")
        tw writeln("    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -m64\")")
        tw writeln("else()")
        tw writeln("    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -m32\")")
        tw writeln("endif()")
        tw nl()

        tw write("set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -I/usr/pkg/include")
        for (flag in flags compilerFlags) {
            tw write(" "). write(flag)
        }
        tw writeln("\")")
        tw nl(). nl()

        tw write("SET(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -L/usr/pkg/lib")
        for(dynamicLib in params dynamicLibs) {
            tw write(" -l "). write(dynamicLib)
        }

        for(libPath in params libPath getPaths()) {
            tw write(" -L "). write(libPath getPath())
        }

        for(linkerFlag in flags linkerFlags) {
            tw write(" "). write(linkerFlag)
        }
        tw write("\")")
        tw nl(). nl()

        targets := HashMap<Int, String> new()
        targets put(Target LINUX, "Linux")
        targets put(Target WIN, "WIN32")
        targets put(Target OSX, "APPLE")
        targets each(|target, name|
            if(Target LINUX == target){
                tw writeln("IF(CMAKE_SYSTEM_NAME STREQUAL Linux)")
                tw write("\tmessage(STATUS \"Found System: ").
                write(name).
                writeln("\")")
                for (useDef in flags uses) {
                    writeUseDef(useDef getPropertiesForTarget(target))
                }
                tw writeln("ENDIF(CMAKE_SYSTEM_NAME STREQUAL Linux)")
                return
            }
            tw write("IF("). write(name). writeln(")")
            tw write("\tmessage(STATUS \"Found System: ").
            write(name).
            writeln("\")")
            for (useDef in flags uses) {
                writeUseDef(useDef getPropertiesForTarget(target))
            }
            tw write("ENDIF("). write(name). write(")"). nl(). nl()
        )

        if(params enableGC) {
            tw writeln("pkg_check_modules(GC REQUIRED bdw-gc)")
            tw writeln("link_directories(${GC_LIBRARY_DIRS})")
            tw writeln("# If there's a threaded version, use it")
            tw writeln("find_library(LIBGC gc-threaded PATHS ${GC_LIBRARY_DIRS})")
            tw writeln("if (LIBGC)")
            tw writeln("else ()")
            tw writeln("	find_library(LIBGC gc PATHS GC_LIBRARY_DIRS)")
            tw writeln("endif ()")
            tw writeln("message(STATUS \"Using Boehm GC library: ${LIBGC}\")")
            tw writeln("include_directories(${GC_INCLUDE_DIRS})")
            tw writeln("set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${GC_CFLAGS}\")")
            tw write("SET(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -lgc\")")

            tw nl()
        }
    }

    writeUseDef: func (props: UseProperties) {
        // cflags
        cflags  := ArrayList<String> new()
        for (path in props includePaths) {
            cflags add("-I" + path)
        }

        if (!cflags empty?()) {
            tw write("\tset(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ")
            for (flag in cflags) {
                tw write(flag). write(" ")
            }
            tw write("\")")
            tw nl()
        }

        // ldflags
        ldflags := ArrayList<String> new()
        ldflags addAll(props libs)
        for (path in props libPaths) {
            ldflags add("-L" + path)
        }
        for (framework in props frameworks) {
            ldflags add("-Wl,-framework," + framework)
        }

        if (!ldflags empty?()) {
            tw write("\tset(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ")
            for (flag in ldflags) {
                tw write(flag). write(" ")
            }
            tw writeln("\")")
            tw nl()
        }

        if(!props pkgs empty?() > 0){
            tw write("\tpkg_check_modules(pkgs REQUIRED ")
            props pkgs each(|name, value|
                tw write(name). write(" "). nl()
            )
            tw writeln(")")
            tw writeln("\tlink_directories(${pkgs_LIBRARY_DIRS})")
            tw writeln("\tinclude_directories(${pkgs_INCLUDE_DIRS})")
            tw writeln("\tset(CMAKE_C_FLAGS ${CMAKE_C_FLAGS} ${pkgs_CFLAGS})")
            tw writeln("\tset(CMAKE_EXE_LINKER_FLAGS ${CAMKE_EXE_LINKER_FLAGS} ${pkgs_CFLAGS})")
            tw nl()
        }

        if(!props customPkgs empty?()){
            props customPkgs each(|customPkg|
                tw write("set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ")
                for (name in customPkg names) {
                    tw write(" "). write(name)
                }
                for (arg in customPkg cflagArgs) {
                    tw write(" "). write(arg)
                }
                tw write("\")"). nl()

                tw write("set(CMAKE_EXE_LINKER_FLAGS \"${CAMKE_EXE_LINKER_FLAGS} ")
                for (name in customPkg names) {
                    tw write(" "). write(name)
                }
                for (arg in customPkg libsArgs) {
                    tw write(" "). write(arg)
                }
                tw write("\")"). nl()
            )
        }
    }

    writeProject: func {
        tw write("project(")
        if(params binaryPath != "") {
            tw write(params binaryPath)
        } else {
            tw write(module simpleName)
        }
        tw write(")")
        tw nl()
    }

    writeExecutable: func{
        tw write("add_executable(")
        if(params binaryPath != "") {
            tw write(params binaryPath)
        } else {
            tw write(module simpleName)
        }
        tw write(" ${cset_SOURCES})"). nl()
    }

    writeIncludes: func{
        tw write("set(cset_HEADERS ")
        for(currentModule in toCompile) {
            path := File new(originalOutPath, currentModule getPath("")) getPath()
            tw write(path). write(".h ").
            write(path). write("-fwd.h ")
        }
        tw writeln(")")
        tw nl()
    }

    writeSources: func{
        tw write("set(cset_SOURCES ")
        for(currentModule in toCompile) {
            path := File new(originalOutPath, currentModule getPath("")) getPath()
            tw write(path). write(".c ")
        }

        for (uze in flags uses) {
            props := uze getRelevantProperties(params)
            for (additional in props additionals) {
                cPath := File new(File new(originalOutPath, uze identifier), additional relative) path
                tw write(cPath). write(" ")
            }

        }
        tw writeln(")")
        tw nl()
    }

    close: func {
        tw close()
    }

}

