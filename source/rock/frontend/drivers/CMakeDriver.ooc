// sdk stuff
import io/[File, FileWriter]
import structs/[List, ArrayList, HashMap]

// our stuff
import Driver, SequenceDriver, CCompiler, Flags, SourceFolder

import rock/frontend/[BuildParams, Target]
import rock/middle/[Module, UseDef]
import rock/backend/cnaughty/CGenerator
import rock/io/TabbedWriter

/**
 * Generate the .c source files in a build/ directory, along with a
 * CMakefile that allows to build a version of your program without any
 * ooc-related dependency.
 */
CMakeDriver: class extends SequenceDriver {

    // the self-containing directory containing buildable C sources
    builddir: File

    // build/CMakeLists.txt
    makefile: File

    // Original output path (e.g. "rock_tmp")
    originalOutPath: File

    init: func (.params) { super(params) }

    setup: func {
        wasSetup := static false
        if(wasSetup) return

        // no lib-caching for the cmake driver!
        params libcache = false

        // keeping them for later (ie. CMakefile invocation)
        params clean = false

        // build/
        builddir = File new("build")

        // build/rock_tmp/
        originalOutPath = params outPath
        params outPath = File new(builddir, params outPath getPath())
        params outPath mkdirs()

        // build/CMakeLists.txt
        makefile = File new(builddir, "CMakeLists.txt")

        wasSetup = true
    }

    compile: func (module: Module) -> Int {

        if(params verbose) {
           "CMake driver" println()
        }

        setup()

        params outPath mkdirs()

        toCompile := ArrayList<Module> new()
        sourceFolders := collectDeps(module, HashMap<String, SourceFolder> new(), toCompile)

        for(candidate in toCompile) {
            CGenerator new(params, candidate) write()
        }

        params libcachePath = params outPath path
        copyLocals(module, params)

        params libcachePath = originalOutPath path
        params libcache = true
        flags := Flags new(null, params)

        // we'll do that ourselves
        flags doTargetSpecific = false

        // we'll handle the GC flags ourselves, thanks
        enableGC := params enableGC
        params enableGC = false
        flags absorb(params)
        params enableGC = enableGC

        for (sourceFolder in sourceFolders) {
            flags absorb(sourceFolder)
        }

        for (module in toCompile) {
            flags absorb(module)
        }
        params libcache = false

        // do the actual writing
        mw := CMakefileWriter new(params, makefile, flags, toCompile, module, originalOutPath)
        mw write()
        mw close()

        return 0

    }

}

CMakefileWriter: class {

    file: File
    flags: Flags
    params: BuildParams
    tw: TabbedWriter
    toCompile: ArrayList<Module>
    module: Module
    originalOutPath: File

    init: func (=params, =file, =flags, =toCompile, =module, =originalOutPath) {
        tw = TabbedWriter new(FileWriter new(file))
    }

    write: func {
        "Writing to %s" printfln(file path)
        writePrelude()
        writeBasicConfig()
        writeProject()
        writePkgConfig()
        writeThreadFlags()
        writeBasicFlags()
        writeFlags()
        writeIncludes()
        writeSources()
        writeExecutable()
        writeLinkLibraries()
    }

    writePrelude: func {
        tw writeln("# CMakeLists.txt generated by rock, the ooc compiler written in ooc")
        tw writeln("# See https://github.com/fasterthanlime/rock and http://ooc-lang.org")
        tw nl()
    }

    writeBasicConfig: func{
        tw writeln("cmake_minimum_required (VERSION 3.0)")
        tw nl()

        tw write("find_program(customCC ").
            write(params compiler executableName). writeln(")")
        tw writeln("IF(EXISTS ${customCC})")
        tw write("\tSET(CMAKE_C_COMPILER \""). write(params compiler executableName).
            write("\")"). nl()
        tw writeln("ENDIF(EXISTS ${customCC})")
        tw writeln("ENABLE_LANGUAGE(C)")
        tw writeln("include(CheckCCompilerFlag)")
        tw nl()
    }

    writePkgConfig: func {
        tw writeln("include(FindPkgConfig)")
    }

    writeThreadFlags: func {
        tw writeln("find_package (Threads)")
        tw writeln("SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${Threads_INCLUDE_DIRS}\")")
        tw writeln("IF(CMAKE_USE_PTHREADS_INIT)")
        tw writeln("  SET(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ${CMAKE_THREAD_LIBS_INIT}\")")
        tw writeln("ENDIF(CMAKE_USE_PTHREADS_INIT)")
        tw nl()
    }

    writeAddCFlags: func(flag: String, tab: Int = 0, variable: String="CMAKE_C_FLAGS", failOnNotExists: Bool = false){
        prefix := ""
        for(i in 0..tab) prefix += "\t"
        tw write(prefix). writeln("check_c_compiler_flag("+flag+" FLAG_"+flag[1..-1]+")")
        tw write(prefix). writeln("IF(FLAG_"+flag[1..-1]+")")
        tw write(prefix). writeln("\tSET("+variable+" \"${"+variable+"} "+flag+"\")")
        if(failOnNotExists){
            tw write(prefix). writeln("ELSE()")
            tw write(prefix). writeln("\tmessage( FATAL_ERROR \"Flag "+flag+" is required but is not supported by compiler\")")
            tw write(prefix). writeln("ENDIF()")
        } else {
            tw write(prefix). writeln("ENDIF(FLAG_"+flag[1..-1]+")")
        }
    }

    writeBasicFlags: func {
        prof := match (params profile){
            case Profile DEBUG => "Debug"
            case Profile RELEASE => "Release"
            case => ""
        }
        if(prof != ""){
            tw writeln("IF( NOT CMAKE_BUILD_TYPE )")
            tw writeln("\tSET( CMAKE_BUILD_TYPE "+ prof + ")")
            tw writeln("ENDIF()")
        }
        optimization := match(params optimization){
            case OptimizationLevel O0 => "-O0"
            case OptimizationLevel O1 => "-O1"
            case OptimizationLevel O2 => "-O2"
            case OptimizationLevel O3 => "-O3"
            case OptimizationLevel Os => "-Os"
            case => ""
        }
        writeAddCFlags("-pg", 0, "CMAKE_C_FLAGS_DEBUG")
        writeAddCFlags(optimization == "" ? "-O0" : optimization, 0, "CMAKE_C_FLAGS_DEBUG")
        writeAddCFlags("-fno-inline", 0, "CMAKE_C_FLAGS_DEBUG")
        writeAddCFlags(optimization == "" ? "-O3" : optimization, 0, "CMAKE_C_FLAGS_RELEASE")
        tw writeln("SET(CMAKE_EXE_LINKER_FLAGS_DEBUG \" ${CMAKE_EXE_LINKER_FLAGS_DEBUG} -pg\")")

        if(prof == "" && optimization != ""){
            writeAddCFlags(optimization)
        }
    }

    writeFlags: func {
        tw writeln("IF(CMAKE_SIZEOF_VOID_P EQUAL 8)")
        tw writeln("\tSET(CMAKE_DET_ARCH_FLAG \"-m64\")")
        tw writeln("ELSE()")
        tw writeln("\tSET(CMAKE_DET_ARCH_FLAG \"-m32\")")
        tw writeln("ENDIF()")
        if(params arch == ""){
            tw writeln("IF(NOT CMAKE_GENERATOR STREQUAL Xcode)")
            writeAddCFlags("${CMAKE_DET_ARCH_FLAG}", 1)
            tw writeln("ENDIF(NOT CMAKE_GENERATOR STREQUAL Xcode)")
        } else {
            tw writeln("IF(NOT \"${CMAKE_DET_ARCH_FLAG}\" MATCHES \"-m"+params arch+"\")")
            tw writeln("\tmessage(WARNING \"You have arch ${CMAKE_DET_ARCH_FLAG} but -m"+params arch+" is used\")")
            tw writeln("ENDIF(NOT \"${CMAKE_DET_ARCH_FLAG}\" MATCHES \"-m"+params arch+"\")")
            writeAddCFlags("-m"+params arch)
        }
        tw nl()

        tw writeln("IF(EXISTS /usr/pkg/include)")
        writeAddCFlags("-I/usr/pkg/include", 1)
        tw writeln("ENDIF(EXISTS /usr/pkg/include)")
        for (flag in flags compilerFlags) {
            writeAddCFlags(flag)
        }

        tw write("SET(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -L/usr/pkg/lib")
        for(dynamicLib in params dynamicLibs) {
            tw write(" -l "). write(dynamicLib)
        }

        for(libPath in params libPath getPaths()) {
            tw write(" -L "). write(libPath getPath())
        }

        for(linkerFlag in flags linkerFlags) {
            tw write(" "). write(linkerFlag)
        }
        tw writeln("\")"). nl()

        targets := HashMap<Int, String> new()
        targets put(Target LINUX, "Linux")
        targets put(Target WIN, "WIN32")
        targets put(Target OSX, "APPLE")
        targets each(|target, name|
            if(Target LINUX == target){
                tw writeln("IF(CMAKE_SYSTEM_NAME STREQUAL Linux)")
                tw write("\tmessage(STATUS \"Found System: ").
                    write(name).
                    writeln("\")")
                for (useDef in flags uses) {
                    writeUseDef(useDef getPropertiesForTarget(target))
                }
                tw writeln("ENDIF(CMAKE_SYSTEM_NAME STREQUAL Linux)")
                return
            }
            tw write("IF("). write(name). writeln(")")
            tw write("\tmessage(STATUS \"Found System: ").
                write(name).
                writeln("\")")
            for (useDef in flags uses) {
                writeUseDef(useDef getPropertiesForTarget(target))
            }
            tw write("ENDIF("). write(name). write(")"). nl(). nl()
        )

        if(params enableGC) {
            tw writeln("pkg_check_modules(GC bdw-gc)")
            tw writeln("link_directories(${GC_LIBRARY_DIRS})")
            if(params dynGC){
                tw writeln("find_library(LIBGC gc-threaded PATHS ${GC_LIBRARY_DIRS})")
                tw writeln("IF(LIBGC)")
                tw writeln("ELSE()")
                tw writeln("\tfind_library(LIBGC gc PATHS GC_LIBRARY_DIRS)")
                tw writeln("ENDIF()")
                tw writeln("if (NOT LIBGC)")
                tw writeln("\tmessage( FATAL_ERROR \"Can not find libgc\" )")
                tw writeln("ENDIF(NOT LIBGC)")
                tw writeln("message(STATUS \"Using Boehm GC library: ${LIBGC}\")")
                tw writeln("include_directories(${GC_INCLUDE_DIRS})")
                tw writeln("SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${GC_CFLAGS}\")")
            } else {
                tw writeln("find_library(LIBGC libgc-threaded.a PATHS ${GC_LIBRARY_DIRS})")
                tw writeln("IF(LIBGC)")
                tw writeln("ELSE()")
                tw writeln("\tfind_library(LIBGC NAMES libgc.a PATHS GC_LIBRARY_DIRS)")
                tw writeln("ENDIF()")
                tw writeln("IF(NOT LIBGC)")
                tw writeln("\tmessage( FATAL_ERROR \"Can not find static libgc\" )")
                tw writeln("ENDIF(NOT LIBGC)")
                tw writeln("message(STATUS \"Using Boehm GC library: ${LIBGC}\")")
                tw writeln("include_directories(${GC_INCLUDE_DIRS})")
                tw writeln("SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${GC_CFLAGS}\")")
                tw writeln("message(STATUS \"Static Boehm GC needs -pthread flag\")")
                tw writeln("IF(WIN32)")
                writeAddCFlags("-mthread", 1, "CMAKE_C_FLAGS", true)
                tw writeln("ELSE()")
                writeAddCFlags("-pthread", 1, "CMAKE_C_FLAGS", true)
                tw writeln("ENDIF()")
            }
            tw nl()
        }
    }

    writeUseDef: func (props: UseProperties) {
        // cflags
        cflags  := ArrayList<String> new()
        for (path in props includePaths) {
            cflags add("-I" + path)
        }

        if (!cflags empty?()) {
            for (flag in cflags) {
                writeAddCFlags(flag)
            }
        }

        // ldflags
        ldflags := ArrayList<String> new()
        ldflags addAll(props libs)
        for (path in props libPaths) {
            ldflags add("-L" + path)
        }
        for (framework in props frameworks) {
            ldflags add("-Wl,-framework," + framework)
        }

        if (!ldflags empty?()) {
            tw write("\tSET(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ")
            for (flag in ldflags) {
                tw write(flag). write(" ")
            }
            tw writeln("\")")
            tw nl()
        }

        if(!props pkgs empty?() > 0){
            tw write("\tpkg_check_modules(pkgs REQUIRED ")
            props pkgs each(|name, value|
                tw write(name). write(" "). nl()
            )
            tw writeln(")")
            tw writeln("\tlink_directories(${pkgs_LIBRARY_DIRS})")
            tw writeln("\tinclude_directories(${pkgs_INCLUDE_DIRS})")
            tw writeln("\tSET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${pkgs_CFLAGS}\")")
            tw writeln("\tSET(CMAKE_EXE_LINKER_FLAGS \"${CAMKE_EXE_LINKER_FLAGS} ${pkgs_CFLAGS}\")")
            tw nl()
        }

        if(!props customPkgs empty?()){
            props customPkgs each(|customPkg|
                tw write("\texecute_process(COMMAND ")
                tw write(customPkg utilName). write(" ")
                for (name in customPkg names) {
                    tw write(" "). write(name)
                }
                for (arg in customPkg cflagArgs) {
                    tw write(" "). write(arg)
                }
                tw writeln(" OUTPUT_VARIABLE custompkgs OUTPUT_STRIP_TRAILING_WHITESPACE)")
                tw writeln("\tSTRING(REGEX REPLACE \"(\\r?\\n)+$\" \"\" custompkgs \"${custompkgs}\")")
                tw writeln("\tSET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${custompkgs} \")")
                tw write("\texecute_process(COMMAND ")
                tw write(customPkg utilName). write(" ")
                for (name in customPkg names) {
                    tw write(" "). write(name)
                }
                for (arg in customPkg libsArgs) {
                    tw write(" "). write(arg)
                }
                tw writeln(" OUTPUT_VARIABLE custompkgs OUTPUT_STRIP_TRAILING_WHITESPACE)")
                tw writeln("\tSTRING(REGEX REPLACE \"(\\r?\\n)+$\" \"\" custompkgs \"${custompkgs}\")")
                tw writeln("\tSET(CMAKE_EXE_LINKER_FLAGS \"${CAMKE_EXE_LINKER_FLAGS} ${custompkgs} \")")
            )
        }
    }

    projectName: func -> (String, Bool){
        projName := ""
        if(params binaryPath != "") {
            projName = params binaryPath
        } else {
            projName = module simpleName
        }
        (projName, module dummy)
    }

    writeProject: func {
        (name, dummy) := projectName()
        tw write("project(")
        tw write(name == "" ? "dummy" : name)
        tw writeln(")")
        tw nl()
    }

    libraryType: func -> String{
        if(params staticLib){
            return "STATIC"
        }
        "SHARED"
    }

    writeExecutable: func{
        (name, dummy) := projectName()
        if(dummy){
            tw write("add_library(")
            tw write(name). write(" ")
            tw write(libraryType())
        } else if(name == ""){
            tw write("add_library(")
            tw write("dummy ")
            tw write(libraryType())
        } else {
            tw write("add_executable(")
            tw write(name)
        }
        tw writeln(" ${cset_SOURCES} )"). nl()
    }

    writeLinkLibraries: func{
        (name, dummy) := projectName()
        tw write("target_link_libraries(").
            write(name == "" ? "dummy" : name).
            write(" ").
            write("${LIBGC})")
    }

    writeIncludes: func{
        tw write("SET(cset_HEADERS ")
        for(currentModule in toCompile) {
            path := File new(originalOutPath, currentModule getPath("")) getPath()
            tw write(path). write(".h ").
            write(path). write("-fwd.h ")
        }
        tw writeln(")"). nl()
    }

    writeSources: func{
        tw write("SET(cset_SOURCES ")
        for(currentModule in toCompile) {
            if(currentModule dummy) continue
            path := File new(originalOutPath, currentModule getPath("")) getPath()
            tw write(path). write(".c ")
        }

        for (uze in flags uses) {
            props := uze getRelevantProperties(params)
            for (additional in props additionals) {
                cPath := File new(File new(originalOutPath, uze identifier), additional relative) path
                tw write(cPath). write(" ")
            }

        }
        tw writeln(")")
        tw nl()
    }

    close: func {
        tw close()
    }

}

